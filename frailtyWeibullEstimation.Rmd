---
title: "Gamma Frailty Model with Weibull Baseline: Covariates in Shape and Scale Parameters, Simulation, Estimation, and Covarage"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(survival)
library(tidyverse)
library(parfm)
library(kableExtra)
```

## 1. Theoretical Background with Covariates in Shape and Scale

We now allow covariates $X$ to influence both the **shape** $k(X)$ and **scale** $\lambda(X)$ parameters:

$$
\log k(X) = k_0 + \gamma^T X, \quad \log \lambda(X) = \lambda_0 + \beta^T X.
$$

This leads to:

$$
h(t|Z,X) = Z \cdot h_0(t|X) = Z \cdot \frac{k(X)}{\lambda(X)^{k(X)}} t^{k(X)-1}.
$$

The cumulative hazard is:

$$
H(t|Z,X) = Z \cdot \left( \frac{t}{\lambda(X)} \right)^{k(X)}.
$$

Integrating out frailty using the Laplace transform gives:

$$
\bar{S}(t|X)=\left[1+\theta H_0(t|X)\right]^{-1/\theta}, \quad \bar{h}(t|X)=\frac{h_0(t|X)}{1+\theta H_0(t|X)}.
$$

## 2. Simulation with Covariates on Shape and Scale

```{r simulation}
set.seed(2025)

n <- 5000
shape_base <- rchisq(1, df = 2)  # base shape parameter
scale_base <- rchisq(1, df = 2)  # base scale parameter
frailty_variance <- rchisq(1, df = 2)  # variance of the frailty distribution
beta_shape <- rnorm(2)   # covariates for shape
beta_scale <- c(log(rchisq(1, df = 2)), rnorm(1))  # covariates for scale

# Covariates
data_cov <- tibble(
  X1 = rbinom(n, 1, 0.5),
  X2 = rnorm(n, mean=0, sd=1)
)

alpha_gamma_sim <- 1/frailty_variance
Z <- rgamma(n, shape=alpha_gamma_sim, rate=alpha_gamma_sim)

X <- as.matrix(data_cov)
shape_ind <- exp(log(shape_base) + X %*% beta_shape)
scale_ind <- exp(log(scale_base) + X %*% beta_scale)

# Simulate survival times
U <- runif(n)
times <- scale_ind * (-log(U)/Z)^(1/shape_ind)

# Censoring
cens_times <- rexp(n, rate=0.05)
observed_times <- pmin(times, cens_times)
event <- as.numeric(times <= cens_times)
```

## 3. Log-Likelihood with Covariates on Shape and Scale

```{r loglikelihood}
weibull_frailty_cov_loglik <- function(params, times, event, X){
  shape_base <- params[1]; scale_base <- params[2]; frailty_var <- params[3]
  p <- ncol(X)
  beta_shape <- params[4:(3+p)]
  beta_scale <- params[(4+p):(3+2*p)]
  
  if(any(c(shape_base, scale_base, frailty_var)<=0)) return(Inf)
  
  alpha_gamma <- 1/frailty_var
  shape_ind <- exp(log(shape_base) + X %*% beta_shape)
  scale_ind <- exp(log(scale_base) + X %*% beta_scale)
  
  H0 <- (times/scale_ind)^shape_ind
  h0 <- (shape_ind/scale_ind^shape_ind)*times^(shape_ind-1)
  S <- (1+H0/alpha_gamma)^(-alpha_gamma)
  h <- h0/(1+H0/alpha_gamma)
  
  if(any(S<=0) || any(event==1 & h<=0)) return(Inf)
  -sum(event*(log(h)+log(S)) + (1-event)*log(S))
}
```

## 4. MLE Estimation with Covariates on Shape and Scale

```{r estimation}
alpha <- 0.05
p <- ncol(X)
init_params <- c(2,1.5,0.3, rep(0, p), rep(0, p))

opt <- optim(init_params, weibull_frailty_cov_loglik,
             times=observed_times, event=event, X=X,
             method="L-BFGS-B",
             lower=c(0.001,0.001,0.01, rep(-Inf,2*p)),
             hessian=TRUE)

est <- opt$par
vcov_mat <- solve(opt$hessian)
se <- sqrt(diag(vcov_mat))
z_val <- qnorm(1-alpha/2)

params_names <- c("Shape Base","Scale Base","Frailty Variance",
                  paste0("Beta_Shape",1:p), paste0("Beta_Scale",1:p))
true_values <- c(shape_base, scale_base, frailty_variance, beta_shape, beta_scale)

ci <- data.frame(
  Parameter=params_names,
  Lower=est - z_val*se,
  `True Values`=true_values,
  Upper=est + z_val*se,
  CI = ifelse(
    true_values >= (est - z_val * se) & true_values <= (est + z_val * se),
    "Yes", "No"
  ),
  Estimate=est,
  SE=se
)

kbl(ci,  align = 'lccccc', digits=3) %>% 
  kableExtra::kable_styling(full_width = FALSE,
                            bootstrap_options = c("striped", "hover", "condensed")) %>%
  column_spec(4, ifelse(ci$CI == "Yes", "background-color: #d4edda;", "background-color: #f8d7da;")) %>% 
  column_spec(5, background = ifelse(ci$CI == "Yes", "lightgreen", "red")) %>% 
  column_spec(5, color = ifelse(ci$CI == "Yes", "black", "white"))

```

## 5. Empirical Bayes Frailties

```{r eb-frailty}
EB_frailty_cov <- function(params,times,event,X){
  shape_base <- params[1]; scale_base <- params[2]; frailty_var <- params[3]
  p <- ncol(X)
  beta_shape <- params[4:(3+p)]
  beta_scale <- params[(4+p):(3+2*p)]
  
  alpha <- 1/frailty_var
  shape_ind <- exp(log(shape_base) + X %*% beta_shape)
  scale_ind <- exp(log(scale_base) + X %*% beta_scale)
  H0 <- (times/scale_ind)^shape_ind
  (alpha+event)/(alpha+H0)
}
frailty_est <- EB_frailty_cov(est, observed_times, event, X)
summary(frailty_est)
```

## 6. Visualization

```{r}
frailty_true_df <- data.frame(frailty=seq(0.03, max(frailty_est)*1.2, length.out=500)) %>%
  mutate(density=dgamma(frailty, shape=1/frailty_variance, rate=1/frailty_variance))

ggplot(data.frame(frailty=frailty_est), aes(x=frailty))+
  geom_histogram(aes(y=after_stat(density)), bins=25, fill="lightcoral", color="red4", alpha=0.6)+
  geom_density(linetype="dashed", color="darkgreen", linewidth=1.2)+
  geom_line(data=frailty_true_df, aes(x=frailty, y=density), color="blue", linewidth=1.2)+
  labs(title="Empirical Bayes Frailty Estimates vs True Distribution",
       x="Frailty (Z)", y="Density",
       caption="Blue: True Gamma Frailty Distribution")+
  theme_minimal()
```

## 7. Coverage Probability Study

```{r coverage, eval = TRUE, cache = TRUE}
coverage_study <- function(n_sim = 500, n = 5000, alpha = 0.05) {
  cover_results <- matrix(NA, nrow = n_sim, ncol = length(true_values))
  colnames(cover_results) <- c("Shape Base","Scale Base","Frailty Var",
                               paste0("Beta_Shape",1:ncol(X)), paste0("Beta_Scale",1:ncol(X)))
  
  ci_records <- list()
  
  for (sim in 1:n_sim) {
    if(interactive()){cat("Running simulation", sim, "of", n_sim, "\n")}
    # --- Simulation ---
    Z <- rgamma(n, shape=1/frailty_variance, rate=1/frailty_variance)
    X <- as.matrix(data_cov)
    shape_ind <- exp(log(shape_base) + X %*% beta_shape)
    scale_ind <- exp(log(scale_base) + X %*% beta_scale)
    U <- runif(n)
    times <- scale_ind * (-log(U)/Z)^(1/shape_ind)
    cens_times <- rexp(n, rate=0.05)
    obs_times <- pmin(times, cens_times)
    event <- as.numeric(times <= cens_times)
    
    # --- Estimation with tryCatch ---
    init_params <- c(2,1.5,0.3, rep(0, ncol(X)), rep(0, ncol(X)))
    opt <- tryCatch(
      optim(init_params, weibull_frailty_cov_loglik,
            times=obs_times, event=event, X=X,
            method="L-BFGS-B",
            lower=c(0.001,0.001,0.01, rep(-Inf,2*ncol(X))),
            hessian=TRUE),
      error = function(e) NULL
    )
    if (is.null(opt) || !is.finite(opt$value)) next
    
    est <- opt$par
    vcov_mat <- tryCatch(solve(opt$hessian), error=function(e) NULL)
    if (is.null(vcov_mat)) next
    
    se <- sqrt(diag(vcov_mat))
    z_val <- qnorm(1-alpha/2)
    lower <- est - z_val*se
    upper <- est + z_val*se
    
    # --- Coverage ---
    cover_results[sim,] <- (true_values >= lower) & (true_values <= upper)
    
    # Record CI info for funnel plot
    ci_df <- data.frame(Parameter=colnames(cover_results),
                        Lower=lower, Estimate=est, Upper=upper,
                        True=true_values, Sim=sim)
    ci_records[[sim]] <- ci_df
  }
  
  cover_results <- cover_results[complete.cases(cover_results),]
  coverage <- colMeans(cover_results)
  ci_all <- do.call(rbind, ci_records)
  return(list(coverage=coverage, ci_data=ci_all))
}

# Run coverage study safely
set.seed(123)
coverage <- coverage_study(n_sim=5)
```

```{r}
print(coverage)
```

```{r}
coverage_df <- data.frame(Parameter=names(coverage$coverage), Coverage=round(coverage$coverage,3))
library(ggplot2)
ggplot(coverage_df, aes(x=Parameter, y=Coverage))+
  geom_col(fill="steelblue")+
  geom_hline(yintercept=0.95, linetype="dashed", color="red")+
  ylim(0,1)+
  labs(title="Coverage Probability by Parameter", y="Coverage", x="Parameter")+
  theme_minimal()
```

```{r coverage_multiN, eval = TRUE, cache = TRUE}
coverage_study_multiN <- function(N_values = c(200, 500, 1000, 2000), n_sim = 200, alpha = 0.05) {
  results_list <- list()
  ci_funnel_list <- list()
  
  for (N in N_values) {
    if(interactive()){cat("Running simulations for N =", N, "\n")}
    cov_res <- coverage_study(n_sim=n_sim, n=N, alpha=alpha)
    coverage <- cov_res$coverage
    ci_data <- cov_res$ci_data
    ci_data$N <- N
    
    df_cov <- data.frame(Parameter=names(coverage), Coverage=as.numeric(coverage), N=N)
    results_list[[as.character(N)]] <- df_cov
    ci_funnel_list[[as.character(N)]] <- ci_data
  }
  
  results_df <- do.call(rbind, results_list)
  ci_funnel_df <- do.call(rbind, ci_funnel_list)
  return(list(coverage_df=results_df, ci_funnel_df=ci_funnel_df))
}
```

```{r, eval = TRUE}
# Run coverage study across multiple N  
set.seed(123)
N_values <- c(50, 100, 200, 500, 1000, 5000)/1
results_multi <- coverage_study_multiN(N_values=N_values, n_sim=10, alpha=0.05)
```


```{r, eval = TRUE}
# save(results_multi, file="output/results_multi.RData")
```


```{r, eval = TRUE}
# Plot coverage across N
ggplot(results_multi$coverage_df, aes(x=N, y=Coverage, color=Parameter, group=Parameter))+
  geom_line(size=1.2)+geom_point(size=2)+geom_hline(yintercept=0.95, linetype="dashed", color="red")+
  ylim(0,1)+labs(title="Coverage Probability Across Sample Sizes", x="Sample Size (N)", y="Coverage")+
  theme_minimal()

ci_funnel_df <- results_multi$ci_funnel_df %>% 
  arrange(N) %>% 
  group_by(Parameter, N) %>%
  summarise(Lower=mean(Lower), Estimate=mean(Estimate),
            Upper=mean(Upper), True=mean(True), .groups='drop')
ggplot(ci_funnel_df, aes(x=N))+
  geom_point(aes(y=Estimate), color="blue", alpha=0.3, size = .5)+
  geom_errorbar(aes(ymin=Lower, ymax=Upper), alpha=0.1)+
  geom_hline(aes(yintercept=True), linetype="dashed", color="red")+
  facet_wrap(~Parameter, scales="free_y")+
  labs(title="Funnel Plot of Confidence Intervals vs Sample Size", y="Parameter Estimate / CI", x="Sample Size (N)")+
  scale_x_log10() +
  theme_void()
```


```{r, eval = FALSE, echo = FALSE}
qqplot_theoretical <- function(est_frailty, shape, rate){
  n <- length(est_frailty)
  gamma_quantiles <- qgamma(ppoints(n), shape=shape, rate=rate)
  qq_df <- data.frame(Theoretical=gamma_quantiles, Estimated=sort(est_frailty))
  ggplot(qq_df, aes(x=Theoretical, y=Estimated))+
    geom_point(color="purple", alpha=0.6)+
    geom_abline(intercept=0, slope=1, color="black", linetype="dashed")+
    labs(title="QQ-Plot: Estimated Frailty vs Gamma(Shape=1/θ, Rate=1/θ)",
         x="Theoretical Gamma Quantiles", y="Estimated Frailty Quantiles")+
    theme_minimal()
}

qqplot_theoretical(frailty_est, shape=1/frailty_variance, rate=1/frailty_variance)
```

```{r}
beepr::beep(2)
```
